

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Compute Log-Determinant (TraceInv.ComputeLogDeterminant) &mdash; TraceInv  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/toggleprompt.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ComputeLogDeterminant" href="api/TraceInv.ComputeLogDeterminant.ComputeLogDeterminant.html" />
    <link rel="prev" title="References" href="references.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> TraceInv
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">Sub-packages</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Compute Log Determinant</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-details">Mathematical Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cholesky-decomposition-method">Cholesky Decomposition Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stochastic-lanczos-quadrature-method">Stochastic Lanczos Quadrature Method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dense-matrix">Dense Matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sparse-matrix">Sparse Matrix</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#main-interface">Main Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-TraceInv.ComputeLogDeterminant">TraceInv.ComputeLogDeterminant Package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#modules">Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-TraceInv.LinearAlgebra.LinearSolver">TraceInv.LinearAlgebra.LinearSolver Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-TraceInv.LinearAlgebra.MatrixReduction">TraceInv.LinearAlgebra.MatrixReduction Module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ComputeTraceOfInverse.html">Compute Trace of Inverse</a></li>
<li class="toctree-l1"><a class="reference internal" href="InterpolateTraceOfInverse.html">Interpolate Trace of Inverse</a></li>
<li class="toctree-l1"><a class="reference internal" href="GenerateMatrix.html">Generate Matrix</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="_modules/modules.html">Package API</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">Running Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Change Log</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TraceInv</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Compute Log-Determinant (<code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeLogDeterminant</span></code>)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ComputeLogDeterminant.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="compute-log-determinant-traceinv-computelogdeterminant">
<span id="computelogdeterminant-userguide"></span><h1>Compute Log-Determinant (<a class="reference internal" href="_modules/TraceInv.ComputeLogDeterminant.html#module-TraceInv.ComputeLogDeterminant" title="TraceInv.ComputeLogDeterminant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeLogDeterminant</span></code></a>)<a class="headerlink" href="#compute-log-determinant-traceinv-computelogdeterminant" title="Permalink to this headline">¶</a></h1>
<p>The sub-package <a class="reference internal" href="_modules/TraceInv.ComputeLogDeterminant.html#module-TraceInv.ComputeLogDeterminant" title="TraceInv.ComputeLogDeterminant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeLogDeterminant</span></code></a> computes the log-determinant of an invertible matrix.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">ComputeLogDeterminant</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute trace of inverse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logdet</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, the class <a class="reference internal" href="_modules/TraceInv.GenerateMatrix.html#module-TraceInv.GenerateMatrix" title="TraceInv.GenerateMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateMatrix</span></code></a> produces a sample matrix for test purposes (see <a class="reference internal" href="api/TraceInv.GenerateMatrix.GenerateMatrix.html#generatematrix"><span class="std std-ref">Generate Matrix</span></a> for details).</p>
<p>The <a class="reference internal" href="_modules/TraceInv.ComputeLogDeterminant.html#module-TraceInv.ComputeLogDeterminant" title="TraceInv.ComputeLogDeterminant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ComputeLogDeterminant</span></code></a> module in the above code employs the Cholesky method by default to compute the log-determinant. However, the user may choose other methods given in the table below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 51%" />
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">ComputeMethod</span></code></p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Matrix size</p></th>
<th class="head"><p>Matrix type</p></th>
<th class="head"><p>Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'cholesky'</span></code></p></td>
<td><p><a class="reference internal" href="#mathdetails-cholesky"><span class="std std-ref">Cholesky decomposition</span></a></p></td>
<td><p>small</p></td>
<td><p>dense, sparse</p></td>
<td><p>exact</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'SLQ'</span></code></p></td>
<td><p><a class="reference internal" href="#mathdetails-slq"><span class="std std-ref">Stochastic Lanczos Quadrature method</span></a></p></td>
<td><p>small or large</p></td>
<td><p>dense, sparse</p></td>
<td><p>approximation</p></td>
</tr>
</tbody>
</table>
<p>The desired method of computation can be passed through the <code class="docutils literal notranslate"><span class="pre">ComputeMethod</span></code> argument when calling <a class="reference internal" href="_modules/TraceInv.ComputeLogDeterminant.html#module-TraceInv.ComputeLogDeterminant" title="TraceInv.ComputeLogDeterminant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ComputeLogDeterminant</span></code></a>. For instance, in the following example, we apply the <em>SLQ randomized estimator</em> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using SLQ method with 20 Monte-Carlo iterations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logdet</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;SLQ&#39;</span><span class="p">,</span><span class="n">NumIterations</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Each of the methods in the above accepts some options. For instance, the SLQ method accepts <a class="reference internal" href="ComputeTraceOfInverse.html#NumIterations" title="NumIterations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">NumIterations</span></code></a> argument, which sets the number of Monte-Carlo trials. To see the detailed list of all arguments for each method, see <a class="reference internal" href="#parameters-logdet"><span class="std std-ref">Parameters</span></a> and the <a class="reference external" href="https://ameli.github.io/TraceInv/_modules/modules.html">API</a> of the package.</p>
</div>
<div class="section" id="parameters">
<span id="parameters-logdet"></span><h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="_modules/TraceInv.ComputeLogDeterminant.html#module-TraceInv.ComputeLogDeterminant" title="TraceInv.ComputeLogDeterminant"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeLogDeterminant</span></code></a> module accepts the following attributes as input argument.</p>
<dl class="py attribute">
<dt id="ComputeMethod">
<code class="sig-name descname">ComputeMethod</code><em class="property">: string</em><em class="property"> = 'cholesky'</em><a class="headerlink" href="#ComputeMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the method of computation. The methods are one of <code class="docutils literal notranslate"><span class="pre">'cholsky'</span></code> and <code class="docutils literal notranslate"><span class="pre">'SLQ'</span></code> (see <span class="xref std std-ref">Mathematical Details &lt;MathDetails_LogDet</span>).</p>
</dd></dl>

<dl class="py attribute">
<dt id="NumIterations">
<code class="sig-name descname">NumIterations</code><em class="property">: int</em><em class="property"> = 20</em><a class="headerlink" href="#NumIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'SLQ'</span></code> computing methods (see <a class="reference internal" href="ComputeTraceOfInverse.html#ComputeMethod" title="ComputeMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ComputeMethod</span></code></a>).</p>
<p>The number of iterations refers to the number of Monte-Carlo samplings during the randomized estimators. With the larger number of Monte-Carlo samples, better numerical convergence is obtained.</p>
<p>For mathematical details of this parameter, see <a class="reference internal" href="#mathdetails-slq"><span class="std std-ref">Stochastic Lanczos quadrature method</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LanczosDegree">
<code class="sig-name descname">LanczosDegree</code><em class="property">: int</em><em class="property"> = 20</em><a class="headerlink" href="#LanczosDegree" title="Permalink to this definition">¶</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'SLQ'</span></code> computing method (see <a class="reference internal" href="ComputeTraceOfInverse.html#ComputeMethod" title="ComputeMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ComputeMethod</span></code></a>).</p>
<p>The Lanczos degree is the number of Lanczos iterations during the Lanczos tridiagonalization process in stochastic Lanczos quadrature (SLQ) method. Larger Lanczos degree yields better numerical convergence.</p>
<p>For mathematical detail of this parameter, see <a class="reference internal" href="#mathdetails-slq"><span class="std std-ref">Stochastic Lanczos quadrature method</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="UseLanczosTridiagonalization">
<code class="sig-name descname">UseLanczosTridiagonalization</code><em class="property">: bool</em><em class="property"> = False</em><a class="headerlink" href="#UseLanczosTridiagonalization" title="Permalink to this definition">¶</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'SLQ'</span></code> computing method (see <a class="reference internal" href="ComputeTraceOfInverse.html#ComputeMethod" title="ComputeMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ComputeMethod</span></code></a>).</p>
<ul class="simple">
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the <em>Lanczos tri-diagonalization</em> method is used.</p></li>
<li><p>When set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the <em>Golub-Kahn-Lanczos bi-diagonalization</em> method is used.</p></li>
</ul>
<p>For mathematical details of this parameter, see <a class="reference internal" href="#mathdetails-slq"><span class="std std-ref">Stochastic Lanczos quadrature method</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="mathematical-details">
<span id="mathdetails-logdet"></span><h2>Mathematical Details<a class="headerlink" href="#mathematical-details" title="Permalink to this headline">¶</a></h2>
<p>The three methods of computing the log-determinant is described below. These methods are categorized into two groups:</p>
<ol class="arabic simple">
<li><p><strong>Exact:</strong> The <a class="reference internal" href="#mathdetails-cholesky"><span class="std std-ref">Cholesky decomposition method</span></a> aims to compute the log-determinant of a matrix exactly. The exact method is expensive and suitable for only small matrices.</p></li>
<li><p><strong>Aproximation:</strong> The <a class="reference internal" href="#mathdetails-slq"><span class="std std-ref">stochastic Lanczos quadrature method</span></a> are <em>randomized estimation algorithms</em> that estimate the log-determinant with <em>Monte-Carlo sampling</em>. These methods do not compute the determinant exactly, but over the iterations, their approximation converges to the true solution. These methods are very suitable for large matrices.</p></li>
</ol>
<div class="section" id="cholesky-decomposition-method">
<span id="mathdetails-cholesky"></span><h3>Cholesky Decomposition Method<a class="headerlink" href="#cholesky-decomposition-method" title="Permalink to this headline">¶</a></h3>
<p>The log-determinant of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> can be computed via</p>
<div class="math notranslate nohighlight">
\[\log | \mathbf{A} | = 2 \mathrm{trace}( \log \mathrm{diag}(\mathbf{L})).\]</div>
<p>In this package, the Cholesky decomposition computed via <a class="reference external" href="https://people.engr.tamu.edu/davis/suitesparse.html">Suite Sparse</a> package <a class="reference internal" href="ComputeTraceOfInverse.html#davis-2006" id="id1"><span>[Davis-2006]</span></a> (see <a class="reference internal" href="install.html#installscikitsparse"><span class="std std-ref">installation</span></a>). If this package is not installed, the Cholesky decomposition is computed using <code class="docutils literal notranslate"><span class="pre">scipy</span></code> package instead.</p>
</div>
<div class="section" id="stochastic-lanczos-quadrature-method">
<span id="mathdetails-slq"></span><h3>Stochastic Lanczos Quadrature Method<a class="headerlink" href="#stochastic-lanczos-quadrature-method" title="Permalink to this headline">¶</a></h3>
<p>The stochastic Lanczos quadrature (SLQ) method combines stochastic estimator and the Gauss quadrature technique. A stochastic estimator approximates the log-determinant by</p>
<div class="math notranslate nohighlight">
\[\log | \mathbf{A} | = \mathrm{trace}(\log \mathbf{A}) = \mathbb{E} \left[ \boldsymbol{q}^{\intercal} (\log \mathbf{A}) \boldsymbol{q} \right]
\approx \frac{n}{m} \sum_{i=1}^m \boldsymbol{q}_i^{\intercal} (\log \mathbf{A}) \boldsymbol{q}_i\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{q}_i\)</span> are unit random vectors obtained from random Rademacher distribution that are normalized to unit norm.</p>
<p>In the SLQ method, first, an <span class="math notranslate nohighlight">\((l \times l)\)</span> tri-diagonal matrix <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is formed by the Lanczos tri-diagonalization of the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> (see p. 57 of <a class="reference internal" href="ComputeTraceOfInverse.html#bai-2000" id="id2"><span>[Bai-2000]</span></a>). The <em>Lanczos degree</em> <span class="math notranslate nohighlight">\(l\)</span> can be set by the parameter <a class="reference internal" href="ComputeTraceOfInverse.html#LanczosDegree" title="LanczosDegree"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LanczosDegree</span></code></a>.</p>
<p>The term on the right side in the above is approximated by the Gaussian quadrature (see <a class="reference internal" href="ComputeTraceOfInverse.html#bai-1996" id="id3"><span>[Bai-1996]</span></a> and <a class="reference internal" href="ComputeTraceOfInverse.html#golub-2009" id="id4"><span>[Golub-2009]</span></a>), by</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{q}_i^{\intercal} (log \mathbf{A}) \boldsymbol{q}_i = \sum_{j=0}^l \left( \tau_{j1} \right)^2 \log \theta_j.\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta_j\)</span> is the <span class="math notranslate nohighlight">\(j\)</span><sup>th</sup> eigenvalue of the tri-diagonalized matrix <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>. Also, <span class="math notranslate nohighlight">\(\tau_{j1}\)</span> is the first element of the vector <span class="math notranslate nohighlight">\(\boldsymbol{\tau}_j = (\tau_{j1},\dots,\tau_{jn})\)</span> where <span class="math notranslate nohighlight">\(\boldsymbol{\tau}_j\)</span> is the <span class="math notranslate nohighlight">\(j\)</span><sup>th</sup> eigenvector of <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> (see Algorithm 1 of <a class="reference internal" href="ComputeTraceOfInverse.html#ubaru-2017" id="id5"><span>[Ubaru-2017]</span></a>).</p>
<p>Alternatively, instead of the tri-diagonalized matrix <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>, one might use the bi-diagonalized matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> that is obtained by Golun-Kahn-Lanczos bi-diagonalization (see p. 143 of <a class="reference internal" href="ComputeTraceOfInverse.html#bai-2000" id="id6"><span>[Bai-2000]</span></a>, p. 495 of <a class="reference internal" href="ComputeTraceOfInverse.html#golub-1996" id="id7"><span>[Golub-1996]</span></a>). This way, the above them is computed by</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{q}_i^{\intercal} \mathbf{A}^{-1} \boldsymbol{q}_i = \sum_{j=0}^l \left( \tau_{j1} \right)^2 \log \phi_j.\]</div>
<p>where here <span class="math notranslate nohighlight">\(\phi_j\)</span> is the <span class="math notranslate nohighlight">\(j\)</span><sup>th</sup> singular value of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>. Also, <span class="math notranslate nohighlight">\(\tau_{j1}\)</span> denotes the first entry of the <span class="math notranslate nohighlight">\(j\)</span><sup>th</sup> right singular vector of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> (see Algorithm 2 of <a class="reference internal" href="ComputeTraceOfInverse.html#ubaru-2017" id="id8"><span>[Ubaru-2017]</span></a>).</p>
<p>In this module, by setting <a class="reference internal" href="ComputeTraceOfInverse.html#UseLanczosTridiagonalization" title="UseLanczosTridiagonalization"><code class="xref py py-attr docutils literal notranslate"><span class="pre">UseLanczosTridiagonalization</span></code></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the Lanczos tri-diagonalization method is applied. Whereas if this parameter is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the Golub-Kahn-Lancos bi-diagonalization is used.</p>
<p>The Golub-Kahn bi-diagonalization method is suitable for non-symmetric matrices. For the symmetric matrices, the Lanczos tri-diagonalization is preferred.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is very close to the identity matrix, the Golub-Kahn bidoagonalization method that
is implementd in this module is unstable.</p>
</div>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dense-matrix">
<h3>Dense Matrix<a class="headerlink" href="#dense-matrix" title="Permalink to this headline">¶</a></h3>
<p>In the code below, we compare the three computing methods for a small dense matrix of the shape <span class="math notranslate nohighlight">\((20^2,20^2)\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Import modules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">ComputeLogDeterminant</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Try various methods</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;cholesky&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;SLQ&#39;</span><span class="p">,</span><span class="n">NumIterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">LanczosDegree</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">UseLanczosTridiagonalization</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;SLQ&#39;</span><span class="p">,</span><span class="n">NumIterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">LanczosDegree</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">UseLanczosTridiagonalization</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The results are shown in the table below. The last column is the elapsed time in seconds. The fifth column is the relative error compared to the Cholesky method. Recall that the Cholesky method computes the log-determinant exactly, hence, it can be used as the benchmark solution. The randomized methods do not much advantage over the exact method for small matrices as their elapsed time higher.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 60%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Method</p></th>
<th class="head"><p>Options</p></th>
<th class="head"><p>Result</p></th>
<th class="head"><p>Error</p></th>
<th class="head"><p>Time</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">D1</span></code></p></td>
<td><p>Cholesky</p></td>
<td><p>N/A</p></td>
<td><p>41.675</p></td>
<td><p>0.00%</p></td>
<td><p>0.00</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">D2</span></code></p></td>
<td><p>SLQ</p></td>
<td><p><span class="math notranslate nohighlight">\(m = 50\)</span>, <span class="math notranslate nohighlight">\(l = 30\)</span>, tri-diagonalization</p></td>
<td><p>38.104</p></td>
<td><p>8.57%</p></td>
<td><p>0.24</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">D3</span></code></p></td>
<td><p>SLQ</p></td>
<td><p><span class="math notranslate nohighlight">\(m = 50\)</span>, <span class="math notranslate nohighlight">\(l = 30\)</span>, bi-diagonalization</p></td>
<td><p>41.466</p></td>
<td><p>0.50%</p></td>
<td><p>0.35</p></td>
</tr>
</tbody>
</table>
<p>The above table can be produced by running the test script <a class="reference external" href="https://github.com/ameli/TraceInv/blob/master/tests/test_ComputeLogDeterminant.py"><code class="docutils literal notranslate"><span class="pre">/test/test_ComputeLogDeterminant.py</span></code></a>, although, the results might be slightly difference due to the random number generator.</p>
</div>
<div class="section" id="sparse-matrix">
<h3>Sparse Matrix<a class="headerlink" href="#sparse-matrix" title="Permalink to this headline">¶</a></h3>
<p>In the code below, we compare the three computing methods for a large sparse matrix of the shape <span class="math notranslate nohighlight">\((50^2,50^2)\)</span> and sparse density <span class="math notranslate nohighlight">\(d = 0.01\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Import modules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">ComputeLogDeterminant</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">KernelThreshold</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span><span class="n">UseSparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">RunInParallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Try various methods</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;cholesky&#39;</span><span class="p">,</span><span class="n">UseInverseMatrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;SLQ&#39;</span><span class="p">,</span><span class="n">NumIterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">LanczosDegree</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">UseLanczosTridiagonalization</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ComputeLogDeterminant</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">ComputeMethod</span><span class="o">=</span><span class="s1">&#39;SLQ&#39;</span><span class="p">,</span><span class="n">NumIterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">LanczosDegree</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">UseLanczosTridiagonalization</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>The results are shown in the table below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 60%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Method</p></th>
<th class="head"><p>Options</p></th>
<th class="head"><p>Result</p></th>
<th class="head"><p>Error</p></th>
<th class="head"><p>Time</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">D1</span></code></p></td>
<td><p>Cholesky</p></td>
<td><p>N/A</p></td>
<td><p>52.052</p></td>
<td><p>0.00%</p></td>
<td><p>2.44</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">D2</span></code></p></td>
<td><p>SLQ</p></td>
<td><p><span class="math notranslate nohighlight">\(m = 50\)</span>, <span class="math notranslate nohighlight">\(l = 30\)</span>, tri-diagonalization</p></td>
<td><p>51.955</p></td>
<td><p>0.19%</p></td>
<td><p>0.76</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">D3</span></code></p></td>
<td><p>SLQ</p></td>
<td><p><span class="math notranslate nohighlight">\(m = 50\)</span>, <span class="math notranslate nohighlight">\(l = 30\)</span>, bi-diagonalization</p></td>
<td><p>51.711</p></td>
<td><p>0.66%</p></td>
<td><p>1.35</p></td>
</tr>
</tbody>
</table>
<p>The advantages of randomized methods can be clearly observed on large sparse matrices. In the above table, the Cholesky method took two minutes, whereas the randomized approaches took one or two seconds to compute. Moreover, a considerable accuracy is achieved with only a few Monte-Carlo sampling (<span class="math notranslate nohighlight">\(m = 50\)</span>). The SLQ method with bi-diagonalization produced less accurate result compared to the tri-diagonalization method. However, by increasing the Lanczos degree, the accuracy of bi-diagonalization method improves.</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="citation">
<dt class="label" id="davis-2006"><span class="brackets"><a class="fn-backref" href="#id1">Davis-2006</a></span></dt>
<dd><p>Davis, T. A. (2006). Direct Methods for Sparse Linear Systems. Society for Industrial and Applied Mathematics, <a class="reference external" href="https://doi.org/10.1137/1.9780898718881">doi: 10.1137/1.9780898718881</a></p>
</dd>
<dt class="label" id="bai-1996"><span class="brackets"><a class="fn-backref" href="#id3">Bai-1996</a></span></dt>
<dd><p>Bai, Z., Fahey, G., and Golub, G. (1996). Some large-scale matrix computation problems. <em>Journal of Computational and Applied Mathematics</em>, 74(1), 71 – 89. <a class="reference external" href="https://doi.org/10.1016/0377-0427(96)00018-0">doi : 10.1016/0377-0427(96)00018-0</a></p>
</dd>
<dt class="label" id="bai-2000"><span class="brackets">Bai-2000</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p>Bai, Z, Demmel, J., Dongarra, J., Ruhe, A., van der Vorst, H. (2000). Templates for the Solution of Algebraic Eigenvalue Problem, A Practical Guide. Society for Industrial and Applied Mathematics. <a class="reference external" href="https://doi.org/10.1137/1.9780898719581">doi:10.1137/1.9780898719581</a></p>
</dd>
<dt class="label" id="golub-1996"><span class="brackets"><a class="fn-backref" href="#id7">Golub-1996</a></span></dt>
<dd><p>Golub, G. H. &amp; Van Loan, C. F. (1996). Matrix Computations. Johns Hopkins Studies in the Mathematical Sciences. Johns Hopkins University Press. <a class="reference external" href="https://jhupbooks.press.jhu.edu/title/matrix-computations">ISBN: 9781421407944</a></p>
</dd>
<dt class="label" id="golub-2009"><span class="brackets"><a class="fn-backref" href="#id4">Golub-2009</a></span></dt>
<dd><p>Golub, G. H. &amp; Meurant, G. (2009). Matrices, Moments and Quadrature with Applications. USA: Princeton University Press. <a class="reference external" href="https://doi.org/10.1007/s10208-010-9082-0">doi: 10.1007/s10208-010-9082-0</a></p>
</dd>
<dt class="label" id="ubaru-2017"><span class="brackets">Ubaru-2017</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p>Ubaru, S., Chen, J., &amp; Saad, Y. (2017). Fast estimation of <span class="math notranslate nohighlight">\(\mathrm{tr}(f(A))\)</span> via stochastic Lanczos quadrature. <em>SIAM Journal on Matrix Analysis and Applications</em>, 38(4), 1075-1099. <a class="reference external" href="https://doi.org/10.1137/16M1104974">doi: 10.1137/16M1104974</a></p>
</dd>
</dl>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="main-interface">
<h3>Main Interface<a class="headerlink" href="#main-interface" title="Permalink to this headline">¶</a></h3>
<div class="section" id="module-TraceInv.ComputeLogDeterminant">
<span id="traceinv-computelogdeterminant-package"></span><h4>TraceInv.ComputeLogDeterminant Package<a class="headerlink" href="#module-TraceInv.ComputeLogDeterminant" title="Permalink to this headline">¶</a></h4>
<div class="section" id="functions">
<h5>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h5>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="api/TraceInv.ComputeLogDeterminant.ComputeLogDeterminant.html#TraceInv.ComputeLogDeterminant.ComputeLogDeterminant" title="TraceInv.ComputeLogDeterminant.ComputeLogDeterminant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComputeLogDeterminant</span></code></a>(A[, ComputeMethod, …])</p></td>
<td><p>Computes the log-determinan of full-rank matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="modules">
<h3>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h3>
<div class="section" id="module-TraceInv.LinearAlgebra.LinearSolver">
<span id="traceinv-linearalgebra-linearsolver-module"></span><h4>TraceInv.LinearAlgebra.LinearSolver Module<a class="headerlink" href="#module-TraceInv.LinearAlgebra.LinearSolver" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id9">
<h5>Functions<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="api/TraceInv.LinearAlgebra.LinearSolver.LinearSolver.html#TraceInv.LinearAlgebra.LinearSolver.LinearSolver" title="TraceInv.LinearAlgebra.LinearSolver.LinearSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearSolver</span></code></a>(A, b[, Tol])</p></td>
<td><p>Solves the linear system <span class="math notranslate nohighlight">\(Ax = b\)</span> where <span class="math notranslate nohighlight">\(A\)</span> can be either sparse or dense.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="module-TraceInv.LinearAlgebra.MatrixReduction">
<span id="traceinv-linearalgebra-matrixreduction-module"></span><h4>TraceInv.LinearAlgebra.MatrixReduction Module<a class="headerlink" href="#module-TraceInv.LinearAlgebra.MatrixReduction" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id10">
<h5>Functions<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="api/TraceInv.LinearAlgebra.MatrixReduction.GolubKahnLanczosBidiagonalization.html#TraceInv.LinearAlgebra.MatrixReduction.GolubKahnLanczosBidiagonalization" title="TraceInv.LinearAlgebra.MatrixReduction.GolubKahnLanczosBidiagonalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GolubKahnLanczosBidiagonalization</span></code></a>(A, w, m[, …])</p></td>
<td><p>B-diagonalizes the positive-definite matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> using Golub-Kahn-Lanczos method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="api/TraceInv.LinearAlgebra.MatrixReduction.LanczosTridiagonalization.html#TraceInv.LinearAlgebra.MatrixReduction.LanczosTridiagonalization" title="TraceInv.LinearAlgebra.MatrixReduction.LanczosTridiagonalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LanczosTridiagonalization</span></code></a>(A, w, m[, Tolerance])</p></td>
<td><p>Tridiagonalizes matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">T</span></code> using the start vector <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api/TraceInv.LinearAlgebra.MatrixReduction.LanczosTridiagonalization2.html#TraceInv.LinearAlgebra.MatrixReduction.LanczosTridiagonalization2" title="TraceInv.LinearAlgebra.MatrixReduction.LanczosTridiagonalization2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LanczosTridiagonalization2</span></code></a>(A, v, m[, Tolerance])</p></td>
<td><p>Tridiagonalizes matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">T</span></code> using the start vector <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api/TraceInv.ComputeLogDeterminant.ComputeLogDeterminant.html" class="btn btn-neutral float-right" title="ComputeLogDeterminant" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="references.html" class="btn btn-neutral float-left" title="References" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Siavash Ameli

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>