

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TraceInv.InterpolateTraceOfInverse package &mdash; TraceInv  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/toggleprompt.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TraceInv.LinearAlgebra package" href="TraceInv.LinearAlgebra.html" />
    <link rel="prev" title="TraceInv.GenerateMatrix package" href="TraceInv.GenerateMatrix.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> TraceInv
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">Sub-packages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ComputeLogDeterminant.html">Compute Log Determinant</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ComputeTraceOfInverse.html">Compute Trace of Inverse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InterpolateTraceOfInverse.html">Interpolate Trace of Inverse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GenerateMatrix.html">Generate Matrix</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Package API</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="TraceInv.html">TraceInv package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="TraceInv.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="TraceInv.ComputeLogDeterminant.html">TraceInv.ComputeLogDeterminant package</a></li>
<li class="toctree-l4"><a class="reference internal" href="TraceInv.ComputeTraceOfInverse.html">TraceInv.ComputeTraceOfInverse package</a></li>
<li class="toctree-l4"><a class="reference internal" href="TraceInv.GenerateMatrix.html">TraceInv.GenerateMatrix package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">TraceInv.InterpolateTraceOfInverse package</a></li>
<li class="toctree-l4"><a class="reference internal" href="TraceInv.LinearAlgebra.html">TraceInv.LinearAlgebra package</a></li>
<li class="toctree-l4"><a class="reference internal" href="TraceInv.Utilities.html">TraceInv.Utilities package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="TraceInv.html#module-TraceInv">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tests.html">Running Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">TraceInv</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">TraceInv</a> &raquo;</li>
        
          <li><a href="TraceInv.html">TraceInv package</a> &raquo;</li>
        
      <li>TraceInv.InterpolateTraceOfInverse package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/_modules/TraceInv.InterpolateTraceOfInverse.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="traceinv-interpolatetraceofinverse-package">
<h1>TraceInv.InterpolateTraceOfInverse package<a class="headerlink" href="#traceinv-interpolatetraceofinverse-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod">
<span id="traceinv-interpolatetraceofinverse-eigenvaluesmethod-module"></span><h2>TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.</code><code class="sig-name descname">EigenvaluesMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">NonZeroRatio</span><span class="o">=</span><span class="default_value">0.9</span></em>, <em class="sig-param"><span class="n">Tolerance</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/EigenvaluesMethod.html#EigenvaluesMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass</span></code></a></p>
<p>Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using eigenvalues of 
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span>  and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.</p>
<p>The trace of computed by</p>
<div class="math notranslate nohighlight">
\[\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right) = \sum_{i = 1}^n \frac{1}{\lambda_i + t \mu_i}\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda_i\)</span> is the eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> 
and <span class="math notranslate nohighlight">\(\mu_i\)</span> is the eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>. 
This class does not accept interpolant points as the result is not interpolated.</p>
<p><strong>Class Inheritance:</strong></p>
<div class="graphviz"><img src="../_images/inheritance-774ac9d0f7048025d604d5952f9488307dd912d6.png" alt="Inheritance diagram of TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod" usemap="#inheritance73058d984f" class="inheritance graphviz" /></div>
<map id="inheritance73058d984f" name="inheritance73058d984f">
<area shape="rect" id="node1" href="../api/TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod.html#TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod" target="_top" title="Computes the trace of inverse of an invertible matrix :math:`mathbf{A} + t mathbf{B}` using eigenvalues of " alt="" coords="213,5,363,31"/>
<area shape="rect" id="node2" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" target="_top" title="This is the base class for the following derived classes:" alt="" coords="5,5,165,31"/>
</map><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of input arguments for <a class="reference internal" href="../api/TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse.html#TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>NonZeroRatio</strong> (<em>int</em>) – The ratio of the number of eigenvalues to be assumed non-zero over all eigenvalues.
This option is only used for sparse matrices where as assume some of eigenvalues are very small 
and we are only interested in computing non-zero eigenvalues. In practice, it is not possible to 
compute all eigenvalues of a large sparse matrix.
Default is <code class="docutils literal notranslate"><span class="pre">0.9</span></code> indicating to compute 90 percent of the eigenvalues with the largest magnitude
and assume the rest of the eigenvalues are zero.</p></li>
<li><p><strong>Tolerance</strong> (<em>float</em>) – Tolerance of computing eigenvalues. This option is only used for sparse matrices.
Default value is <code class="docutils literal notranslate"><span class="pre">1e-3</span></code>.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrices <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> can be either sparse or dense.
In case of a <strong>sparse matrix</strong>, only some of the eigenvalues with the largest magnitude is computed 
and the rest of its eigenvalues is assumed to be negligible. The ratio of computed eigenvalues over 
the total number of eigenvalues can be set by <code class="docutils literal notranslate"><span class="pre">NonZeroRatio</span></code>.
The tolerance at which the eigenvalues are computed can be set by <code class="docutils literal notranslate"><span class="pre">Tolerance</span></code>.</p>
</div>
<p><strong>Example:</strong></p>
<p>This class can be invoked from <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.html#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse</span></code></a> module 
using <code class="docutils literal notranslate"><span class="pre">InterpolationMethod='EIG'</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an object that interpolates trace of inverse of A+tI (I is identity matrix)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolatiionMethod</span><span class="o">=</span><span class="s1">&#39;EIG&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some input point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The result of the <code class="docutils literal notranslate"><span class="pre">EIG</span></code> method is identical with the exact method <code class="docutils literal notranslate"><span class="pre">EXT</span></code>, 
which is given by <a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.ExactMethod" title="TraceInv.InterpolateTraceOfInverse.ExactMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.ExactMethod</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod.InitializeInterpolator">
<code class="sig-name descname">InitializeInterpolator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/EigenvaluesMethod.html#EigenvaluesMethod.InitializeInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod.InitializeInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the <code class="docutils literal notranslate"><span class="pre">A_eigenvalues</span></code> and <code class="docutils literal notranslate"><span class="pre">B_eigenvalues</span></code>  member data of the class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is sparse, it is not possible to find all of its eigenvalues. We only find
a fraction of the number of its eigenvalues with the larges magnitude and
we assume the rest of the eigenvalues are close to zero.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/EigenvaluesMethod.html#EigenvaluesMethod.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod.EigenvaluesMethod.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the function <span class="math notranslate nohighlight">\(\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> 
at the input point <span class="math notranslate nohighlight">\(t\)</span> by</p>
<div class="math notranslate nohighlight">
\[\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right) = \sum_{i = 1}^n \frac{1}{\lambda_i + t \mu_i}\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda_i\)</span> is the eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.
and  <span class="math notranslate nohighlight">\(\mu_i\)</span> is the eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>t: An inquiry point, which can be a single number, or an array of numbers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The exact value of the trace of inverse of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">tB</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.ExactMethod">
<span id="traceinv-interpolatetraceofinverse-exactmethod-module"></span><h2>TraceInv.InterpolateTraceOfInverse.ExactMethod module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.ExactMethod" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.ExactMethod.ExactMethod">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.ExactMethod.</code><code class="sig-name descname">ExactMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/ExactMethod.html#ExactMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.ExactMethod.ExactMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass</span></code></a></p>
<p>Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using 
exact method (no interpolation is performed).
This class does not accept interpolant points as the result is not interpolated, rather, used
as a benchmark to compare the exact versus the interpolated solution of the other classes.</p>
<p><strong>Class Inheritance:</strong></p>
<div class="graphviz"><img src="../_images/inheritance-2d6900359c08c505aaf8bcf5d0b65a636c4e829f.png" alt="Inheritance diagram of TraceInv.InterpolateTraceOfInverse.ExactMethod" usemap="#inheritancebbaf9648af" class="inheritance graphviz" /></div>
<map id="inheritancebbaf9648af" name="inheritancebbaf9648af">
<area shape="rect" id="node1" href="../api/TraceInv.InterpolateTraceOfInverse.ExactMethod.ExactMethod.html#TraceInv.InterpolateTraceOfInverse.ExactMethod.ExactMethod" target="_top" title="Computes the trace of inverse of an invertible matrix :math:`mathbf{A} + t mathbf{B}` using " alt="" coords="213,5,320,31"/>
<area shape="rect" id="node2" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" target="_top" title="This is the base class for the following derived classes:" alt="" coords="5,5,165,31"/>
</map><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em><em> or </em><em>scipy.sparse.csc_matrix</em>) – A positive-definite matrix. Matrix can be dense or sparse.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em><em> or </em><em>scipy.sparse.csc_matrix</em>) – A positive-definite matrix. 
If <code class="docutils literal notranslate"><span class="pre">None</span></code> or not provided, it is assumed that <code class="docutils literal notranslate"><span class="pre">B</span></code> is an identity matrix of the shape of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of arguments to pass to <a class="reference internal" href="TraceInv.ComputeTraceOfInverse.html#module-TraceInv.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<p>This class can be invoked from <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.html#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse</span></code></a> module 
using <code class="docutils literal notranslate"><span class="pre">InterpolationMethod='EXT'</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an object that interpolates trace of inverse of A+tI (I is identity matrix)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;EXT&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some input point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The result of the <code class="docutils literal notranslate"><span class="pre">EXT</span></code> method is identical with the eigenvalue method <code class="docutils literal notranslate"><span class="pre">EIG</span></code>, 
which is given by <a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod" title="TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.ExactMethod.ExactMethod.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/ExactMethod.html#ExactMethod.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.ExactMethod.ExactMethod.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This function does not interpolate, rather exactly computes 
:math:<a href="#id1"><span class="problematic" id="id2">`</span></a>mathrm{trace} left( (mathbf{A} + t mathbf{B})^{-1}</p>
</div></blockquote>
<p>right)`</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param t</dt>
<dd class="field-odd"><p>The inquiry point(s).</p>
</dd>
<dt class="field-even">type t</dt>
<dd class="field-even"><p>float, list, or numpy.array</p>
</dd>
<dt class="field-odd">return</dt>
<dd class="field-odd"><p>The exact value of the trace.</p>
</dd>
<dt class="field-even">rtype</dt>
<dd class="field-even"><p>float or numpy.array</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass">
<span id="traceinv-interpolatetraceofinverse-interpolantbaseclass-module"></span><h2>TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.</code><code class="sig-name descname">InterpolantBaseClass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolantPoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is the base class for the following derived classes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.ExactMethod" title="TraceInv.InterpolateTraceOfInverse.ExactMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.ExactMethod</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod" title="TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.EigenvaluesMethod</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod" title="TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod" title="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod" title="TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod" title="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod</span></code></a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em><em> or </em><em>scipy.sparse.csc_matrix</em>) – A positive-definite matrix. Matrix can be dense or sparse.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em><em> or </em><em>scipy.sparse.csc_matrix</em>) – A positive-definite matrix. Matrix can be dense or sparse.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> or not provided, it is assumed that <code class="docutils literal notranslate"><span class="pre">B</span></code> is an identity matrix of the shape of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p><strong>InterpolantPoints</strong> (<em>list</em><em>(</em><em>float</em><em>) or </em><em>numpy.array</em><em>(</em><em>float</em><em>)</em>) – A list or an array of points that the interpolator use to interpolate. 
The trace of inverse is computed for the interpolant points with exact method.</p></li>
<li><p><strong>InterpolationMethod</strong> (<em>string</em>) – One of the methods <code class="docutils literal notranslate"><span class="pre">'EXT'</span></code>, <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'MBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'RPF'</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of arguments to pass to <a class="reference internal" href="TraceInv.ComputeTraceOfInverse.html#module-TraceInv.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.Compute">
<code class="sig-name descname">Compute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass.Compute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.Compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(\mathrm{trace}\left( (\mathbf{A}+t \mathbf{B})^{-1} \right)\)</span> at point <span class="math notranslate nohighlight">\(t\)</span> with exact method, that is,
no interpolation is used and the result is exact.</p>
<p>This function is primarily used internally to compute trace of inverse at <em>interpolant points</em>. 
This function uses <a class="reference internal" href="TraceInv.ComputeTraceOfInverse.html#module-TraceInv.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse</span></code></a> class with options described by
<code class="docutils literal notranslate"><span class="pre">self.ComputeOptions</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Trace of inverse at input point <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.ComputeTraceForArrayOfPoints">
<code class="sig-name descname">ComputeTraceForArrayOfPoints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_i</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass.ComputeTraceForArrayOfPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.ComputeTraceForArrayOfPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(\mathrm{trace} \left( (\mathbf{A}+ t \mathbf{B})^{-1} \right)\)</span> at interpolant points 
<code class="docutils literal notranslate"><span class="pre">self.InterpolantPoints</span></code>. At interpolant points, the trace is computed exactly 
using <a class="reference internal" href="TraceInv.ComputeTraceOfInverse.html#module-TraceInv.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t_i</strong> (<em>float</em><em>, </em><em>numpy.ndarray</em><em>, or </em><em>list</em><em>(</em><em>float</em><em>)</em>) – An array if inquiry points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Trace of inverse at inquiry points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.ComputeTraceInvOfInputMatrices">
<code class="sig-name descname">ComputeTraceInvOfInputMatrices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass.ComputeTraceInvOfInputMatrices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.ComputeTraceInvOfInputMatrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the trace of inverse of input matrices <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>, and the ratio <span class="math notranslate nohighlight">\(\tau_0\)</span>
defined by</p>
<div class="math notranslate nohighlight">
\[\tau_0 = \frac{\mathrm{trace}( \mathbf{A}^{-1})}{\mathrm{trace}( \mathbf{B}^{-1})}.\]</div>
<p>This function sets the following class attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.trace_Ainv</span></code>: trace of inverse of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.trace_Binv</span></code>: trace of inverse of <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.tau0</span></code>: the ratio of <code class="docutils literal notranslate"><span class="pre">self.trace_Ainv</span></code> over <code class="docutils literal notranslate"><span class="pre">self.trace_Binv</span></code>.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.LowerBound">
<code class="sig-name descname">LowerBound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass.LowerBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.LowerBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower bound of the function <span class="math notranslate nohighlight">\(t \mapsto \mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span>.</p>
<p>The lower bound is given by Remark 2.2 of <a class="reference internal" href="../references.html#ameli-2020" id="id3"><span>[Ameli-2020]</span></a> as</p>
<div class="math notranslate nohighlight">
\[\mathrm{trace}((\mathbf{A}+t\mathbf{B})^{-1}) \geq \frac{n^2}{\mathrm{trace}(\mathbf{A}) + \mathrm{trace}(t \mathbf{B})}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em> or </em><em>numpy.ndarray</em>) – Inquiry points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Lower bound of the trace of inverse at inquiry points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.ScaleInterpolantPoints">
<code class="sig-name descname">ScaleInterpolantPoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass.ScaleInterpolantPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.ScaleInterpolantPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the range of interpolant points. This function is intended to be used internally.</p>
<p>If the largest interpolant point in <code class="docutils literal notranslate"><span class="pre">self.InterpolantPoints</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">1</span></code>, 
this function rescales their range to max at <code class="docutils literal notranslate"><span class="pre">1</span></code>.  The rescale is necessary if the method of 
interpolation is based on the orthogonal basis functions, which they are defined to be orthogonal 
in the range <span class="math notranslate nohighlight">\(t \in [0,1]\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.UpperBound">
<code class="sig-name descname">UpperBound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolantBaseClass.html#InterpolantBaseClass.UpperBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass.UpperBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper bound of the function <span class="math notranslate nohighlight">\(t \mapsto \mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span>.</p>
<p>The upper bound is given by Theorem 1 of <a class="reference internal" href="../references.html#ameli-2020" id="id4"><span>[Ameli-2020]</span></a> as</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\tau(t)} \geq \frac{1}{\tau_0} + t\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1}  \right)}{\mathrm{trace}(\mathbf{B}^{-1})}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tau_0 = \tau(0)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em> or </em><em>numpy.ndarray</em>) – Inquiry points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Upper bound of the trace of inverse at inquiry points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse">
<span id="traceinv-interpolatetraceofinverse-interpolatetraceofinverse-module"></span><h2>TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.</code><code class="sig-name descname">InterpolateTraceOfInverse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolantPoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolationMethod</span><span class="o">=</span><span class="default_value">'RMBF'</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{'ComputeMethod': 'cholesky'}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">InterpolationOptions</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolates the trace of inverse of affine matrix functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em><em> or </em><em>scipy.sparse.csc_matrix</em>) – A positive-definite matrix. Matrix can be dense or sparse.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em><em> or </em><em>scipy.sparse.csc_matrix</em>) – A positive-definite matrix. Matrix can be dense or sparse.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> or not provided, it is assumed that <code class="docutils literal notranslate"><span class="pre">B</span></code> is an identity matrix of the shape of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p><strong>InterpolantPoints</strong> (<em>list</em><em>(</em><em>float</em><em>) or </em><em>numpy.array</em><em>(</em><em>float</em><em>)</em>) – A list or an array of points that the interpolator use to interpolate. 
The trace of inverse is computed for the interpolant points with exact method.</p></li>
<li><p><strong>InterpolationMethod</strong> (<em>string</em>) – One of the methods <code class="docutils literal notranslate"><span class="pre">'EXT'</span></code>, <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'MBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'RPF'</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of arguments to pass to <a class="reference internal" href="TraceInv.ComputeTraceOfInverse.html#module-TraceInv.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>InterpolationOptions</strong> (<em>**kwargs</em>) – Additional options to pass to each specific interpolator class. 
See the sub-classes of <code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.InterpolantBaseClass</span></code>.</p></li>
</ul>
</dd>
</dl>
<p><strong>Methods:</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 41%" />
<col style="width: 12%" />
<col style="width: 13%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Matrix size</p></th>
<th class="head"><p>Matrix type</p></th>
<th class="head"><p>Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'EXT'</span></code></p></td>
<td><p>Computes trace directly, no interpolation</p></td>
<td><p>Small</p></td>
<td><p>dense, sparse</p></td>
<td><p>exact</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'EIG'</span></code></p></td>
<td><p>Uses Eigenvalues of matrix</p></td>
<td><p>Small</p></td>
<td><p>dense, sparse</p></td>
<td><p>exact</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'MBF'</span></code></p></td>
<td><p>Monomial Basis Functions</p></td>
<td><p>Small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code></p></td>
<td><p>Root monomial basis functions</p></td>
<td><p>small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'RBF'</span></code></p></td>
<td><p>Radial basis functions</p></td>
<td><p>small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'RPF'</span></code></p></td>
<td><p>Rational polynomial functions</p></td>
<td><p>small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
</tbody>
</table>
<p><strong>Details:</strong></p>
<p>An affine matrix function is defined by</p>
<div class="math notranslate nohighlight">
\[t \mapsto \mathbf{A} + t \mathbf{B}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> are invertible matrices and <span class="math notranslate nohighlight">\(t\)</span> is a real parameter.</p>
<p>This module interpolates the function</p>
<div class="math notranslate nohighlight">
\[t \mapsto \mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\]</div>
<p>The interpolator is initialized by providing <span class="math notranslate nohighlight">\(p\)</span> interpolant points <span class="math notranslate nohighlight">\(t_i\)</span>, <span class="math notranslate nohighlight">\(i = 1,\dots,p\)</span>,
which are often logarithmically spaced in some interval <span class="math notranslate nohighlight">\(t_i \in [t_1,t_p]\)</span>. 
The interpolator can interpolate the above function at inquity points <span class="math notranslate nohighlight">\(t \in [t_1,t_p]\)</span> 
using various methods.</p>
<p><strong>Examples:</strong></p>
<p>Interpolate the trace of inverse of the affine matrix function <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate two sample matrices (symmetric and positive-definite)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">2e-2</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialize interpolator object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">InterpolantPoints</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1e1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate at an inquiry point t = 0.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Interpolate an array of inquiry points</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate at an array of points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_array</span> <span class="o">=</span> <span class="n">numoy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolator</span><span class="p">(</span><span class="n">t_array</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, the interpolation method is <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>. Use a different interpolation method, such as <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code> by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, the trace is computed with the Cholesky decomposition method as the interpolant points. Configure the
computation method by <code class="docutils literal notranslate"><span class="pre">ComputeOptions</span></code> as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify arguments to TraceInv.ComputeTraceOfInverse in a dictionary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComputeOptions</span> <span class="o">=</span> \ 
<span class="gp">... </span><span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;ComputeMethod&#39;</span><span class="p">:</span> <span class="s1">&#39;hutchinson&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;NumIterations&#39;</span><span class="p">:</span> <span class="mi">20</span>
<span class="gp">... </span><span class="p">}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Pass the options to the interpolator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This module calls a derived class of the base class <a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.CompareWithExactSolution">
<code class="sig-name descname">CompareWithExactSolution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">Trace</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse.CompareWithExactSolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.CompareWithExactSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the trace with exact method (no interpolation), then compares it with 
the interpolated solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>numpy.ndarray</em>) – Inquiry points</p></li>
<li><p><strong>Trace</strong> (<em>float</em><em> or </em><em>numpy.ndarray</em>) – The interpolated computation of trace.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Exact solution of trace.</p></li>
<li><p>Relative error of interpolated solution compared to the exact solution.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>float or numpy.ndarray</p></li>
<li><p>float or numpy.ndarray</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.Compute">
<code class="sig-name descname">Compute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse.Compute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.Compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the function <span class="math notranslate nohighlight">\(\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> 
at the input point <span class="math notranslate nohighlight">\(t\)</span> using exact method.</p>
<p>The computation method used in this function is exact (no interpolation). This function 
is primarily used to compute trace on the <em>interpolant points</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>t: An inquiry point, which can be a single number, or an array of numbers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The exact value of the trace</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">CompareWithExact</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">Plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates <span class="math notranslate nohighlight">\(\mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> at <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This is the main interface function of this module and it is used after the interpolation
object is initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float</em><em>, </em><em>list</em><em>, or </em><em>numpy.array</em>) – The inquiry point(s).</p></li>
<li><p><strong>CompareWithExact</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it computes the trace with exact solution, then compares it with the interpolated 
solution. The return values of the <code class="docutils literal notranslate"><span class="pre">Interpolate()</span></code> functions become interpolated trace, exact solution, 
and relative error. <strong>Note:</strong> When this option is enabled, the exact solution will be computed for all inquiry points, 
which can take a very long time. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>Plot</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it plots the interpolated trace versus the inquiry points. In addition, if the option
<code class="docutils literal notranslate"><span class="pre">CompareWithExact</span></code> is also set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the plotted diagram contains both interpolated and exact solutions
and the relative error of interpolated solution with respect to the exact solution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated value of the trace.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.LowerBound">
<code class="sig-name descname">LowerBound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse.LowerBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.LowerBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower bound of the function <span class="math notranslate nohighlight">\(t \mapsto \mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span>.</p>
<p>The lower bound is given by</p>
<div class="math notranslate nohighlight">
\[\mathrm{trace}((\mathbf{A}+t\mathbf{B})^{-1}) \geq \frac{n^2}{\mathrm{trace}(\mathbf{A}) + \mathrm{trace}(t \mathbf{B})}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em> or </em><em>numpy.array</em>) – An inquiry point or an array of inquiry points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Lower bound of the affine matrix function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This function is implemented in <code class="xref py py-meth docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.LowerBound()</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.PlotInterpolation">
<code class="sig-name descname">PlotInterpolation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">InquiryPoints</span></em>, <em class="sig-param"><span class="n">Trace_Interpolated</span></em>, <em class="sig-param"><span class="n">Trace_Exact</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Trace_RelativeError</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse.PlotInterpolation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.PlotInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the interpolation results, together with the comparison with the exact solution and
the relative error of the interpolation.</p>
<p>To plot, set <code class="docutils literal notranslate"><span class="pre">Plot=True</span></code> argument in <a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>InquiryPoints</strong> (<em>numpy.ndarray</em>) – Inquiry points</p></li>
<li><p><strong>Trace_Interpolated</strong> (<em>numpy.ndarray</em>) – Interpolation of the trace at inquiry points.</p></li>
<li><p><strong>Trace_Exact</strong> (<em>numpy.ndarray</em>) – Exact solutions of the trace at inquiry points. 
If this variable is not None, it will be plotted together with the interpolated results.</p></li>
<li><p><strong>Trace_RelativeError</strong> (<em>numpy.ndarray</em>) – Relative errors of the interpolation with respect to the exact solution.
If not None, the relative errors will be plotted on a second axis.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.UpperBound">
<code class="sig-name descname">UpperBound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/InterpolateTraceOfInverse.html#InterpolateTraceOfInverse.UpperBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.InterpolateTraceOfInverse.UpperBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper bound of the function <span class="math notranslate nohighlight">\(t \mapsto \mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span>.</p>
<p>The upper bound is given by</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\tau(t)} \geq \frac{1}{\tau_0} + t\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1}  \right)}{\mathrm{trace}(\mathbf{B}^{-1})}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tau_0 = \tau(0)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em> or </em><em>numpy.array</em>) – An inquiry point or an array of inquiry points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Lower bound of the affine matrix function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This function is implemented in <code class="xref py py-meth docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.UpperBound()</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod">
<span id="traceinv-interpolatetraceofinverse-monomialbasisfunctionsmethod-module"></span><h2>TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.</code><code class="sig-name descname">MonomialBasisFunctionsMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolantPoint</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/MonomialBasisFunctionsMethod.html#MonomialBasisFunctionsMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass</span></code></a></p>
<p>Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using</p>
<div class="math notranslate nohighlight">
\[\frac{1}{(\tau(t))^{p+1}} = \frac{1}{(\tau_0)^{p+1}} + \sum_{i=1}^{p+1} w_i t^i,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)}{\mathrm{trace \left( \mathbf{B}^{-1} \right)}}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tau_0 = \tau(0)\)</span> and <span class="math notranslate nohighlight">\(w_{p+1} = 1\)</span>. 
To find the weight coefficient <span class="math notranslate nohighlight">\(w_1\)</span>, the trace is computed at the given 
interpolant point <span class="math notranslate nohighlight">\(t_1\)</span> (see <code class="docutils literal notranslate"><span class="pre">InterpolantPoint</span></code> argument).</p>
<p>When <span class="math notranslate nohighlight">\(p = 1\)</span>, meaning that there is only one interpolant point <span class="math notranslate nohighlight">\(t_1\)</span> with the function value 
<span class="math notranslate nohighlight">\(\tau_1 = \tau(t_1)\)</span>, the weight coefficient <span class="math notranslate nohighlight">\(w_1\)</span> can be solved easily. In this case, 
the interpolation function becomes</p>
<div class="math notranslate nohighlight">
\[\frac{1}{(\tau(t))^2} \approx  \frac{1}{\tau_0^2} + t^2 + \left( \frac{1}{\tau_1^2} - \frac{1}{\tau_0^2} - t_1^2 \right) \frac{t}{t_1}.\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class accepts only <em>one</em> interpolant point (<span class="math notranslate nohighlight">\(p = 1\)</span>). That is, the argument
<code class="docutils literal notranslate"><span class="pre">InterpolantPoint</span></code> should be only one number or a list of the length 1.</p>
</div>
<p><strong>Class Inheritance:</strong></p>
<div class="graphviz"><img src="../_images/inheritance-01887e1ca385569c44bf1b3493d08357899cc56d.png" alt="Inheritance diagram of TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod" usemap="#inheritance7b38cd99f7" class="inheritance graphviz" /></div>
<map id="inheritance7b38cd99f7" name="inheritance7b38cd99f7">
<area shape="rect" id="node1" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" target="_top" title="This is the base class for the following derived classes:" alt="" coords="5,5,165,31"/>
<area shape="rect" id="node2" href="../api/TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod.html#TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod" target="_top" title="Computes the trace of inverse of an invertible matrix :math:`mathbf{A} + t mathbf{B}` using" alt="" coords="213,5,444,31"/>
</map><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of input arguments for <a class="reference internal" href="../api/TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse.html#TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><p></p></dd>
</dl>
<p>This class can be invoked from <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.html#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse</span></code></a> module 
using <code class="docutils literal notranslate"><span class="pre">InterpolationMethod='MBF'</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an object that interpolates trace of inverse of A+tI (I is identity matrix)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolatingMethod</span><span class="o">=</span><span class="s1">&#39;MBF&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some input point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This class can only accept one interpolant point. A better method is <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code> which 
accepts arbitrary number of interpolant points. It is recommended to use the
<code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code> (see <a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod" title="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod</span></code></a>) instead of this class.</p>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod.InitializeInterpolator">
<code class="sig-name descname">InitializeInterpolator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/MonomialBasisFunctionsMethod.html#MonomialBasisFunctionsMethod.InitializeInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod.InitializeInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the trace at the interpolant point. This function is used internally.</p>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/MonomialBasisFunctionsMethod.html#MonomialBasisFunctionsMethod.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod.MonomialBasisFunctionsMethod.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates <span class="math notranslate nohighlight">\(\mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> at <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This is the main interface function of this module and it is used after the interpolation
object is initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em>, </em><em>list</em><em>, or </em><em>numpy.array</em>) – The inquiry point(s).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated value of the trace.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod">
<span id="traceinv-interpolatetraceofinverse-radialbasisfunctionsmethod-module"></span><h2>TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.</code><code class="sig-name descname">RadialBasisFunctionsMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolantPoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">FunctionType</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RadialBasisFunctionsMethod.html#RadialBasisFunctionsMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass</span></code></a></p>
<p>Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using 
an interpolation scheme based on rational polynomial functions (see details below).</p>
<p><strong>Class Inheritance:</strong></p>
<div class="graphviz"><img src="../_images/inheritance-30dbe917df5003179c96286a796745734e34d069.png" alt="Inheritance diagram of TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod" usemap="#inheritancefd824eb8e1" class="inheritance graphviz" /></div>
<map id="inheritancefd824eb8e1" name="inheritancefd824eb8e1">
<area shape="rect" id="node1" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" target="_top" title="This is the base class for the following derived classes:" alt="" coords="5,5,165,31"/>
<area shape="rect" id="node2" href="../api/TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod.html#TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod" target="_top" title="Computes the trace of inverse of an invertible matrix :math:`mathbf{A} + t mathbf{B}` using " alt="" coords="213,5,420,31"/>
</map><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of input arguments for <a class="reference internal" href="../api/TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse.html#TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>FunctionType</strong> (<em>int</em>) – Can be <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, or <code class="docutils literal notranslate"><span class="pre">3</span></code>, which defines different radial basis functions (see details below).</p></li>
</ul>
</dd>
</dl>
<p><strong>Interpolation Method</strong></p>
<p>Define the function</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)}{\mathrm{trace}(\mathbf{B}^{-1})}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tau_0 = \tau(0)\)</span>. Then, we approximate <span class="math notranslate nohighlight">\(\tau(t)\)</span> by radial basis functions as follows. Define</p>
<div class="math notranslate nohighlight">
\[x(t) = \log t\]</div>
<p>Depending whether <code class="docutils literal notranslate"><span class="pre">FunctionType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, or <code class="docutils literal notranslate"><span class="pre">3</span></code>, one of the following functions is defined:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray}
y_1(t) &amp;= \frac{1}{\tau(t)} - \frac{1}{\tau_0} - t, \\
y_2(t) &amp;= \frac{\frac{1}{\tau(t)}}{\frac{1}{\tau_0} + t} - 1, \\
y_3(t) &amp;= 1 - \tau(t) \left( \frac{1}{\tau_0} + t \right).
\end{eqnarray}</div><ul class="simple">
<li><p>The set of data <span class="math notranslate nohighlight">\((x,y_1(x))\)</span> are interpolated using <em>cubic splines</em>.</p></li>
<li><p>The set of data <span class="math notranslate nohighlight">\((x,y_2(x))\)</span> and <span class="math notranslate nohighlight">\((x,y_3(x))\)</span> are interpolated using <em>Gaussian radial basis functions</em>.</p></li>
</ul>
<p><strong>Example</strong></p>
<p>This class can be invoked from <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.html#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse</span></code></a> module 
using <code class="docutils literal notranslate"><span class="pre">InterpolationMethod='RBF'</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an object that interpolates trace of inverse of A+tI (I is identity matrix)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolatingMethod</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some input point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod.InitializeInterpolator">
<code class="sig-name descname">InitializeInterpolator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RadialBasisFunctionsMethod.html#RadialBasisFunctionsMethod.InitializeInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod.InitializeInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the coefficients of the interpolating function.</p>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RadialBasisFunctionsMethod.html#RadialBasisFunctionsMethod.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RadialBasisFunctionsMethod.RadialBasisFunctionsMethod.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates <span class="math notranslate nohighlight">\(\mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> at <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This is the main interface function of this module and it is used after the interpolation
object is initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em>, </em><em>list</em><em>, or </em><em>numpy.array</em>) – The inquiry point(s).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated value of the trace.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod">
<span id="traceinv-interpolatetraceofinverse-rationalpolynomialfunctionsmethod-module"></span><h2>TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.</code><code class="sig-name descname">RationalPolynomialFunctionsMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolantPoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RationalPolynomialFunctionsMethod.html#RationalPolynomialFunctionsMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass</span></code></a></p>
<p>Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using 
an interpolation scheme based on rational polynomial functions (see details below).</p>
<p><strong>Class Inheritance:</strong></p>
<div class="graphviz"><img src="../_images/inheritance-881329c272787f82b32bbf6ddfc4c17f1f0d707f.png" alt="Inheritance diagram of TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod" usemap="#inheritance555c48ff52" class="inheritance graphviz" /></div>
<map id="inheritance555c48ff52" name="inheritance555c48ff52">
<area shape="rect" id="node1" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" target="_top" title="This is the base class for the following derived classes:" alt="" coords="5,5,165,31"/>
<area shape="rect" id="node2" href="../api/TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.html#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod" target="_top" title="Computes the trace of inverse of an invertible matrix :math:`mathbf{A} + t mathbf{B}` using " alt="" coords="213,5,472,31"/>
</map><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of input arguments for <a class="reference internal" href="../api/TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse.html#TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
</dl>
<p><strong>Interpolation Method</strong></p>
<p>Define the function</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)}{\mathrm{trace}(\mathbf{B}^{-1})}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tau_0 = \tau(0)\)</span>. Then, we approximate <span class="math notranslate nohighlight">\(\tau^{-1}(t)\)</span> by</p>
<div class="math notranslate nohighlight">
\[\tau(t) \approx \frac{t^p + a_{p-1} t^{p-1} + \cdots + a_1 t + a_0}{t^{p+1} + b_p t^p + \cdots + b_1 t + b_0}\]</div>
<p>where <span class="math notranslate nohighlight">\(a_0 = b_0 \tau_0\)</span>. The rest of coefficients are found by solving a linear system using the 
function value at the interpolant points <span class="math notranslate nohighlight">\(\tau_i = \tau(t_i)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The number of interpolant points <span class="math notranslate nohighlight">\(p\)</span> in this module can be only <span class="math notranslate nohighlight">\(p = 2\)</span> or <span class="math notranslate nohighlight">\(p = 4\)</span>.</p>
</div>
<p><strong>Example</strong></p>
<p>This class can be invoked from <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.html#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse</span></code></a> module 
using <code class="docutils literal notranslate"><span class="pre">InterpolationMethod='RPF'</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an object that interpolates trace of inverse of A+tI (I is identity matrix)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolatingMethod</span><span class="o">=</span><span class="s1">&#39;RPF&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some input point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.InitializeInterpolator">
<code class="sig-name descname">InitializeInterpolator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RationalPolynomialFunctionsMethod.html#RationalPolynomialFunctionsMethod.InitializeInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.InitializeInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">self.Numerator</span></code> and <code class="docutils literal notranslate"><span class="pre">self.Denominator</span></code> which are list of the coefficients of the
numerator and denominator of the rational polynomial.</p>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RationalPolynomialFunctionsMethod.html#RationalPolynomialFunctionsMethod.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates <span class="math notranslate nohighlight">\(\mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> at <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This is the main interface function of this module and it is used after the interpolation
object is initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em>, </em><em>list</em><em>, or </em><em>numpy.array</em>) – The inquiry point(s).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated value of the trace.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.RationalPoly">
<code class="sig-name descname">RationalPoly</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">Numerator</span></em>, <em class="sig-param"><span class="n">Denominator</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RationalPolynomialFunctionsMethod.html#RationalPolynomialFunctionsMethod.RationalPoly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.RationalPoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates rational polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float</em>) – Inquiry point.</p></li>
<li><p><strong>Numerator</strong> (<em>list</em>) – A list of coefficients of polynomial in the numerator of the rational polynomial function.</p></li>
<li><p><strong>Denominator</strong> – A list of coefficients of polynomial in the denominator of the rational polynomial function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.RationalPoly12">
<code class="sig-name descname">RationalPoly12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_i</span></em>, <em class="sig-param"><span class="n">tau_i</span></em>, <em class="sig-param"><span class="n">tau0</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RationalPolynomialFunctionsMethod.html#RationalPolynomialFunctionsMethod.RationalPoly12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.RationalPoly12" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the coefficients <span class="math notranslate nohighlight">\((a_0,b_1,b_0)\)</span> of a Rational polynomial of order 1 over 2,</p>
<div class="math notranslate nohighlight">
\[\tau(t) \approx \frac{t + a_0}{t^2 + b_1 t + b_0}\]</div>
<p>This is used when the number of interpolant points is <span class="math notranslate nohighlight">\(p = 2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_i</strong> (<em>float</em>) – Inquiry point.</p></li>
<li><p><strong>tau_i</strong> (<em>float</em>) – The function value at the inquiry point <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><strong>tau_0</strong> (<em>float</em>) – The function value at <span class="math notranslate nohighlight">\(t_0 = 0\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.RationalPoly23">
<code class="sig-name descname">RationalPoly23</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_i</span></em>, <em class="sig-param"><span class="n">tau_i</span></em>, <em class="sig-param"><span class="n">tau0</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RationalPolynomialFunctionsMethod.html#RationalPolynomialFunctionsMethod.RationalPoly23"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RationalPolynomialFunctionsMethod.RationalPolynomialFunctionsMethod.RationalPoly23" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the coefficients <span class="math notranslate nohighlight">\((a_1,a_0,b_2,b_1,b_0)\)</span> of a Rational polynomial of order 2 over 3,</p>
<div class="math notranslate nohighlight">
\[\tau(t) \approx \frac{t^2 + a_{1} t + a_0}{t^3 + b_2 t^2 + b_1 t + b_0}\]</div>
<p>This is used when the number of interpolant points is <span class="math notranslate nohighlight">\(p = 4\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_i</strong> (<em>float</em>) – Inquiry point.</p></li>
<li><p><strong>tau_i</strong> (<em>float</em>) – The function value at the inquiry point <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><strong>tau_0</strong> (<em>float</em>) – The function value at <span class="math notranslate nohighlight">\(t_0 = 0\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod">
<span id="traceinv-interpolatetraceofinverse-rootmonomialbasisfunctionsmethod-module"></span><h2>TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod module<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod">
<em class="property">class </em><code class="sig-prename descclassname">TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.</code><code class="sig-name descname">RootMonomialBasisFunctionsMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">InterpolantPoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ComputeOptions</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">Verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">BasisFunctionsType</span><span class="o">=</span><span class="default_value">'Orthogonal2'</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RootMonomialBasisFunctionsMethod.html#RootMonomialBasisFunctionsMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" title="TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass</span></code></a></p>
<p>Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using 
an interpolation scheme based on root monomial basis functions (see details below).</p>
<p><strong>Class Inheritance:</strong></p>
<div class="graphviz"><img src="../_images/inheritance-ed54f8423ea51761d3d4699e00a9a27975252f26.png" alt="Inheritance diagram of TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod" usemap="#inheritance4504cd62b7" class="inheritance graphviz" /></div>
<map id="inheritance4504cd62b7" name="inheritance4504cd62b7">
<area shape="rect" id="node1" href="#TraceInv.InterpolateTraceOfInverse.InterpolantBaseClass.InterpolantBaseClass" target="_top" title="This is the base class for the following derived classes:" alt="" coords="5,5,165,31"/>
<area shape="rect" id="node2" href="../api/TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.html#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod" target="_top" title="Computes the trace of inverse of an invertible matrix :math:`mathbf{A} + t mathbf{B}` using " alt="" coords="213,5,472,31"/>
</map><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>B</strong> (<em>numpy.ndarray</em>) – Invertible matrix, can be either dense or sparse matrix.</p></li>
<li><p><strong>ComputeOptions</strong> (<em>dict</em>) – A dictionary of input arguments for <a class="reference internal" href="../api/TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse.html#TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse" title="TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.ComputeTraceOfInverse.ComputeTraceOfInverse</span></code></a> module.</p></li>
<li><p><strong>Verbose</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information on the computation process. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>BasisFunctionsType</strong> – One of the types <code class="docutils literal notranslate"><span class="pre">'NonOrthogonal'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Orthogonal'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Orthogonal2'</span></code>. 
Default is <code class="docutils literal notranslate"><span class="pre">'orthogonal2'</span></code>.</p></li>
</ul>
</dd>
</dl>
<p><strong>Interpolation Method</strong></p>
<p>Define the function</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)}{\mathrm{trace}(\mathbf{B}^{-1})}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tau_0 = \tau(0)\)</span>. Then, we approximate <span class="math notranslate nohighlight">\(\tau^{-1}(t)\)</span> by</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\tau(t)} \approx \frac{1}{\tau_0} + \sum_{i = 0}^p w_i \phi_i(t),\]</div>
<p>where  <span class="math notranslate nohighlight">\(\phi_i\)</span> are some known basis functions, and <span class="math notranslate nohighlight">\(w_i\)</span> are the coefficients of the linear basis functions.
The first coefficient is set to <span class="math notranslate nohighlight">\(w_{0} = 1\)</span> and the rest of the weights 
are to be found form the known function values <span class="math notranslate nohighlight">\(\tau_i = \tau(t_i)\)</span> at some given interpolant points <span class="math notranslate nohighlight">\(t_i\)</span>.</p>
<p><strong>Basis Functions:</strong></p>
<p>In this module, three kinds of basis functions which can be set by the argument <code class="docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">NonOrthogonal</span></code>, the basis functions are the
root of the monomial functions defined by</p>
<div class="math notranslate nohighlight">
\[\phi_i(t) = t^{\frac{1}{i+1}}, \qquad i = 0,\dots,p.\]</div>
<p>When <code class="docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'Orthogonal'</span></code> or <code class="docutils literal notranslate"><span class="pre">'Orthogonal2'</span></code>, the orthogoanl form of the
above basis functions are used. Orthogonal basis functions are formed by the above non-orthogonal functions
as</p>
<div class="math notranslate nohighlight">
\[\phi_i^{\perp}(t) = \alpha_i \sum_{j=1}^i a_{ij} \phi_j(t)\]</div>
<p>The coefficients <span class="math notranslate nohighlight">\(\alpha_i\)</span> and <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be obtained by the python package 
<a class="reference external" href="https://ameli.github.io/Orthogonal-Functions">Orthogoanl Functions</a>. These coefficients are
hard-coded in this function up to <span class="math notranslate nohighlight">\(i = 9\)</span>. Thus, in this module, up to nine interpolant points
are supported.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The non-orhtogonal basis functions can lead to ill-conditioned system of equations for finding the weight
coefficients <span class="math notranslate nohighlight">\(w_i\)</span>. When the number of interpolating points is large (such as <span class="math notranslate nohighlight">\(p &gt; 6\)</span>), 
it is recommended to use the orthogonalized set of basis functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The recommended basis function type is <a href="#id5"><span class="problematic" id="id6">``</span></a>’Orthogonal2’<cite>.</cite></p>
</div>
<p><strong>Example</strong></p>
<p>This class can be invoked from <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse.html#TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse" title="TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.InterpolateTraceOfInverse</span></code></a> module 
using <code class="docutils literal notranslate"><span class="pre">InterpolationMethod='RMBF'</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">TraceInv</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an object that interpolates trace of inverse of A+tI (I is identity matrix)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolatingMethod</span><span class="o">=</span><span class="s1">&#39;RMBF&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some input point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The other class that provides interpolation with basis functions method is 
<a class="reference internal" href="#module-TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod" title="TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.MonomialBasisFunctionsMethod</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.BasisFunctions">
<code class="sig-name descname">BasisFunctions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RootMonomialBasisFunctionsMethod.html#RootMonomialBasisFunctionsMethod.BasisFunctions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.BasisFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the basis functions at inquiry point <span class="math notranslate nohighlight">\(t\)</span></p>
<p>The index j of the basis functions should start from 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em>) – Inquiry point.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Basis functions at inquiry point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p>Depending on <code class="docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code>, the basis functions are:</p>
<ul>
<li><p>For <code class="docutils literal notranslate"><span class="pre">NonOrthogonal</span></code>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\phi_i(t) = t^{\frac{1}{i}}, \qquad i &gt; 0\]</div>
</div></blockquote>
</li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">Orthogonal</span></code>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\phi_i^{\perp}(t) = \alpha_i \sum_{j=1}^9 a_{ij} \phi_j(t)\]</div>
</div></blockquote>
</li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">Orthogona2</span></code>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\phi_i^{\perp}(t) = \alpha_i \sum_{j=1}^9 a_{ij} \phi_{j+1}(t)\]</div>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The difference between <code class="docutils literal notranslate"><span class="pre">Orthogonal</span></code> and <code class="docutils literal notranslate"><span class="pre">Orthogonal2</span></code> is that in the former,
the functions <span class="math notranslate nohighlight">\(\phi_j^{\perp}\)</span> at <span class="math notranslate nohighlight">\(j=1,\dots,9\)</span> are orthogonal
but in the latter, the functions at <span class="math notranslate nohighlight">\(j=2,\dots,9\)</span> are orthogonal. That is
they are not orthogonal to <span class="math notranslate nohighlight">\(\phi_1(t) = t\)</span>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.InitializeInterpolator">
<code class="sig-name descname">InitializeInterpolator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RootMonomialBasisFunctionsMethod.html#RootMonomialBasisFunctionsMethod.InitializeInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.InitializeInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal function that is called by the class constructor. It computes the weight coefficients
<span class="math notranslate nohighlight">\(w_i\)</span> and stores them in the member variable <code class="docutils literal notranslate"><span class="pre">self.w</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.Interpolate">
<code class="sig-name descname">Interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RootMonomialBasisFunctionsMethod.html#RootMonomialBasisFunctionsMethod.Interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.Interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates <span class="math notranslate nohighlight">\(\mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span> at <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This is the main interface function of this module and it is used after the interpolation
object is initialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em><em>, </em><em>list</em><em>, or </em><em>numpy.array</em>) – The inquiry point(s).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated value of the trace.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or numpy.array</p>
</dd>
</dl>
<p><strong>Details:</strong></p>
<p>Depending on the <code class="docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code>, the interpolation is as follows:</p>
<p>For <code class="docutils literal notranslate"><span class="pre">'NonOrthogonal'</span></code> basis:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\tau(t)} = \frac{1}{\tau_0} + t + \sum_{j=1}^p w_j \phi_j(t).\]</div>
<p>For <code class="docutils literal notranslate"><span class="pre">'Orthogonal'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Orthogonal2'</span></code> bases:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\tau(t)} = \frac{1}{\tau_0} + t + \sum_{j=1}^p w_j \phi_j(t).\]</div>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.OrthogonalBasisFunctionCoefficients">
<code class="sig-name descname">OrthogonalBasisFunctionCoefficients</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RootMonomialBasisFunctionsMethod.html#RootMonomialBasisFunctionsMethod.OrthogonalBasisFunctionCoefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.OrthogonalBasisFunctionCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Hard-coded coefficients <span class="math notranslate nohighlight">\(\alpha_i\)</span> and <span class="math notranslate nohighlight">\(a_{ij}\)</span> which will be
used by <a class="reference internal" href="../api/TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.html#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.BasisFunctions" title="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.BasisFunctions"><code class="xref py py-func docutils literal notranslate"><span class="pre">TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.BasisFunctions()</span></code></a> 
to form the orthogonal basis:</p>
<div class="math notranslate nohighlight">
\[\phi_i^{\perp}(t) = \alpha_i \sum_{j=0}^9 a_{ij} \phi_j(t).\]</div>
<p><strong>Generate coefficients:</strong></p>
<p>To generate these coefficients, see the python package 
<a class="reference external" href="https://ameli.github.io/Orthogonal-Functions">Orthogonal Functions</a>.</p>
<p>Install this package by</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">OrthogonalFunctions</span>
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p>To generate the coefficients corresponding to <code class="docutils literal notranslate"><span class="pre">Orthogonal</span></code> basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span><span class="o">-</span><span class="n">orth</span> <span class="o">-</span><span class="n">n</span> <span class="mi">9</span> <span class="o">-</span><span class="n">s</span> <span class="mi">0</span>
</pre></div>
</div>
</li>
<li><p>To generate the coefficients corresponding to <code class="docutils literal notranslate"><span class="pre">Orthogonal2</span></code> basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span><span class="o">-</span><span class="n">orth</span> <span class="o">-</span><span class="n">n</span> <span class="mi">9</span> <span class="o">-</span><span class="n">s</span> <span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Weight coefficients of the orthogonal basis functions.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.array, numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.phi">
<em class="property">static </em><code class="sig-name descname">phi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference internal" href="TraceInv/InterpolateTraceOfInverse/RootMonomialBasisFunctionsMethod.html#RootMonomialBasisFunctionsMethod.phi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TraceInv.InterpolateTraceOfInverse.RootMonomialBasisFunctionsMethod.RootMonomialBasisFunctionsMethod.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-orthogonal basis function, which is defined by</p>
<div class="math notranslate nohighlight">
\[\phi_i(t) = t^{\frac{1}{i}}, \qquad i &gt; 0.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>float</em>) – Inquiry point.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The value of the function <span class="math notranslate nohighlight">\(\phi(t)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-TraceInv.InterpolateTraceOfInverse">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-TraceInv.InterpolateTraceOfInverse" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="TraceInv.LinearAlgebra.html" class="btn btn-neutral float-right" title="TraceInv.LinearAlgebra package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="TraceInv.GenerateMatrix.html" class="btn btn-neutral float-left" title="TraceInv.GenerateMatrix package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Siavash Ameli

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>